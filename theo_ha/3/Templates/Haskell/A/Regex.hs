import Control.Arrow (first)
import Control.Monad
import Data.Char (isAlphaNum, isSpace, chr, ord)
import Data.List
import qualified Data.Set as S
import Data.Set (Set)
import qualified Data.ByteString as BS
import Data.Word
import Data.Bits
import Data.Ord


-- Definition of regexes

infixl 6 :|:
infixl 7 :.:

data Regex = Empty | Epsilon | Single Char | Regex :|: Regex | Regex :.: Regex | Star Regex
  deriving (Ord, Eq)

size :: Integral a => Regex -> a
size Empty      = 1
size Epsilon    = 1
size (Single _) = 1
size (r :|: s)  = size r + size s + 1
size (r :.: s)  = size r + size s + 1
size (Star r)   = size r + 1

-- Pretty printing

instance Show Regex where
  show = showRegexPrec 0
    where parens a b s = if a > b then "(" ++ s ++ ")" else s
          showRegexPrec :: Int -> Regex -> String
          showRegexPrec _ Empty      = "∅"
          showRegexPrec _ Epsilon    = "ε"
          showRegexPrec _ (Single c) = [c]
          showRegexPrec p (r :|: s)  = parens p 0 (showRegexPrec 0 r ++ "|" ++ showRegexPrec 0 s)
          showRegexPrec p (r :.: s)  = parens p 1 (showRegexPrec 1 r ++ showRegexPrec 1 s)
          showRegexPrec _ (Star r)   = showRegexPrec 2 r ++ "*"

-- Parsing

isSymbol :: Char -> Bool
isSymbol = isAlphaNum

-- this is a very ad-hoc parser, but it seems to work well
parseRegex :: String -> Regex
parseRegex s = case parse1 (filter (not . isSpace) s) of
                 (r, []) -> r
                 (_, c : _)  -> error $ "Expected end of input, but found '" ++ [c] ++ "'"
  where term _ [] = True
        term cs (x : _) = x `elem` cs
        
        parse1 s = case s' of
                     '|' : s'' -> first (r :|:) (parse1 s'')
                     ')' : _   -> (r, s')
                     []        -> (r, [])
                     c : _     -> error $ "Unexpected character '" ++ [c] ++ "'" 
          where (r, s') = parse2 s
        
        parse2 s | term "|)" s = (Epsilon, s)
        parse2 s = if term "|)" s' then (r, s') else first (r :.:) (parse2 s')
          where (r, s') = parse3 s
          
        parseStar r ('*' : s) = parseStar (Star r) s
        parseStar r s         = (r, s)
        
        parse3 ('{' : '}' : s) = parseStar Empty s
        parse3 ('∅' : s) = parseStar Empty s
        parse3 ('ε' : s) = parseStar Epsilon s
        parse3 ('*' : s) = parseStar (Star Epsilon) s
        parse3 ('(' : s) = case parse1 s of
                             (r, ')' : s') -> parseStar r s'
                             _            -> error "Missing closing ')'"
        parse3 (c : s) | isSymbol c = parseStar (Single c) s
        parse3 (c : _)   = error $ "Unexpected character '" ++ [c] ++ "'"



-- Implementation of operations

-- Returns whether the language generated by the regular expression is empty
isEmpty :: Regex -> Bool
isEmpty Empty      = True
isEmpty Epsilon    = False
isEmpty (Single _) = False
isEmpty (r :|: s)  = isEmpty r && isEmpty s
isEmpty (r :.: s)  = isEmpty r || isEmpty s
isEmpty (Star _)   = False

-- Returns whether the language generated by the regular expression is trivial, i.e.
-- either empty of only contains the empty word
isTrivial :: Regex -> Bool
isTrivial r = undefined -- TODO

-- Returns the language generated by the regular expression as a set if it is finite,
-- or "Nothing" if it is infinite
getLanguage :: Regex -> Maybe (Set String)
getLanguage r = undefined -- TODO



-- Input/output

main =
  do mode <- myGetLine
     loop (if mode == "Trivial" then testTrivial else testLanguage)
  where loop m = do s <- myGetLine
                    when (s /= "END") (myPrintLine (m (parseRegex s)) >> loop m)
        testTrivial r = if isTrivial r then "yes" else "no"
        testLanguage = maybe "infinite" showLanguage . getLanguage
          where showLanguage l = "{" ++ intercalate ", " (map showWord (S.toList l)) ++ "}"
                showWord w     = if null w then "ε" else w



-- Some UTF8 magic required because the TUMjudge uses a strange locale

myGetLine = fmap decodeUtf8 BS.getLine
myPrintLine s = BS.putStr . encodeUtf8 $ s ++ "\n"

encodeUtf8 :: String -> BS.ByteString
encodeUtf8 = BS.pack . encode

decodeUtf8 :: BS.ByteString -> String
decodeUtf8 = decode . BS.unpack

replacementCharacter :: Char
replacementCharacter = '\xfffd'

encode :: String -> [Word8]
encode = concatMap (map fromIntegral . go . ord)
 where
  go oc
   | oc <= 0x7f       = [oc]

   | oc <= 0x7ff      = [ 0xc0 + (oc `shiftR` 6)
                        , 0x80 + oc .&. 0x3f
                        ]

   | oc <= 0xffff     = [ 0xe0 + (oc `shiftR` 12)
                        , 0x80 + ((oc `shiftR` 6) .&. 0x3f)
                        , 0x80 + oc .&. 0x3f
                        ]
   | otherwise        = [ 0xf0 + (oc `shiftR` 18)
                        , 0x80 + ((oc `shiftR` 12) .&. 0x3f)
                        , 0x80 + ((oc `shiftR` 6) .&. 0x3f)
                        , 0x80 + oc .&. 0x3f
                        ]

decode :: [Word8] -> String
decode [    ] = ""
decode (c:cs)
  | c < 0x80  = chr (fromEnum c) : decode cs
  | c < 0xc0  = replacementCharacter : decode cs
  | c < 0xe0  = multi1
  | c < 0xf0  = multi_byte 2 0xf  0x800
  | c < 0xf8  = multi_byte 3 0x7  0x10000
  | c < 0xfc  = multi_byte 4 0x3  0x200000
  | c < 0xfe  = multi_byte 5 0x1  0x4000000
  | otherwise = replacementCharacter : decode cs
  where
    multi1 = case cs of
      c1 : ds | c1 .&. 0xc0 == 0x80 ->
        let d = ((fromEnum c .&. 0x1f) `shiftL` 6) .|.  fromEnum (c1 .&. 0x3f)
        in if d >= 0x000080 then toEnum d : decode ds
                            else replacementCharacter : decode ds
      _ -> replacementCharacter : decode cs

    multi_byte :: Int -> Word8 -> Int -> String
    multi_byte i mask overlong = aux i cs (fromEnum (c .&. mask))
      where
        aux 0 rs acc
          | overlong <= acc && acc <= 0x10ffff &&
            (acc < 0xd800 || 0xdfff < acc)     &&
            (acc < 0xfffe || 0xffff < acc)      = chr acc : decode rs
          | otherwise = replacementCharacter : decode rs

        aux n (r:rs) acc
          | r .&. 0xc0 == 0x80 = aux (n-1) rs
                               $ shiftL acc 6 .|. fromEnum (r .&. 0x3f)

        aux _ rs     _ = replacementCharacter : decode rs

